# Supporting both SQLite3 and Postgresql in Diesel

## 1  File-layout options

| Option | How it works | When to choose it |
| --- | --- | --- |
| **B. Pure-Rust migrations** | Implement `diesel::migration::Migration<DB>` in a Rust file (`up.rs` / `down.rs`) and compile with both `features = ["postgres", "sqlite"]`.  The query builder emits backend-specific SQL at runtime. | You prefer the type-checked DSL and can live with slightly slower compile times. |
| **C. Lowest-common-denominator SQL** | Write one `up.sql`/`down.sql` that *already* works on both engines.  This demands avoiding SERIAL/IDENTITY, JSONB, `TIMESTAMPTZ`, etc. | Simple schemas, embedded use-case only, you are happy to supply integer primary keys manually. |
| **D. Two separate migration trees** | Maintain `migrations/sqlite` and `migrations/postgres` directories with identical version numbers. Use `embed_migrations!("migrations/<backend>")` to compile the right set. | You ship a single binary with migrations baked in. |

> **Tip:** if you go with *B* or *D* keep your migration *versions* identical so
> that the two databases stay in lock-step. Diesel’s `__diesel_schema_migrations`
> table stores the numeric version only, so you can swap back-ends without
> confusing the tracker.

---

## 2  Writing portable DDL

### 2.1  Primary keys & auto-increment

- **PostgreSQL** – use identity columns (*preferred*)

  ```sql
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
  ```

  (`SERIAL` still works but is officially discouraged.)

- **SQLite** – the only flavour that keeps the hidden `ROWID` semantics is

  ```sql
  id INTEGER PRIMARY KEY AUTOINCREMENT
  ```

  So you usually have two variant files here.

### 2.2 Column types that line up cleanly

| Logical type | PostgreSQL | SQLite notes |
| --- | --- | --- |
| strings | `TEXT` (or `VARCHAR`) | `TEXT` – SQLite ignores the length specifier anyway |
| booleans | `BOOLEAN DEFAULT FALSE` | declare as `BOOLEAN`; Diesel serialises to 0 / 1 so this is fine |
| integers | `INTEGER` / `BIGINT` | ditto |
| decimals | `NUMERIC(…)` | stored as FLOAT in SQLite; Diesel’s `Numeric` round-trips, but beware precision |
| blobs / raw | `BYTEA` | `BLOB` |

Things that **do *not* port** and therefore need conditional SQL:

- `TIMESTAMP WITH TIME ZONE` → store UTC as naive `TIMESTAMP` on both, or dual
  files with `TIMESTAMPTZ` vs `DATETIME`.
- `CHECK (…)` constraints that rely on PostgreSQL operators/functions.
- JSON / JSONB (Postgres-only without extensions).
- Expression indexes (`CREATE INDEX … (lower(email))`) – Postgres supports them,
  SQLite prior to 3.40 does not.

### 2.3 Default values

- Use `DEFAULT CURRENT_TIMESTAMP` on SQLite, `DEFAULT now()` on Postgres.
- Boolean defaults: `DEFAULT 0` is accepted by both engines, even though
  Postgres treats it as `BOOLEAN`.

---

## 3 Putting it together: a minimal dual-backend migration

```text
migrations/
└─ 20250605142700_create_users/
   ├─ up.postgres.sql
   ├─ down.postgres.sql
   ├─ up.sqlite.sql
   └─ down.sqlite.sql
```

`up.postgres.sql`

```sql
CREATE TABLE users (
    id          INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    username    TEXT      NOT NULL UNIQUE,
    email       TEXT      NOT NULL UNIQUE,
    active      BOOLEAN   NOT NULL DEFAULT FALSE,
    created_at  TIMESTAMP NOT NULL DEFAULT now()
);
```

`up.sqlite.sql`

```sql
CREATE TABLE users (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    username    TEXT    NOT NULL UNIQUE,
    email       TEXT    NOT NULL UNIQUE,
    active      BOOLEAN NOT NULL DEFAULT 0,
    created_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

`down.*.sql` is identical on both engines:

```sql
DROP TABLE users;
```

### Corresponding `schema.rs`

```rust
diesel::table! {
    use diesel::sql_types::*;
    users (id) {
        id          -> Integer,
        username    -> Text,
        email       -> Text,
        active      -> Bool,
        created_at  -> Timestamp,
    }
}
```

Because the *Rust* side deals in Diesel’s abstract `Integer`, `Text`, `Bool`,
`Timestamp` types, the same code compiles for both back-ends. Compile with

```toml
[features]
default = []
postgres = [
    "diesel/postgres",
    "diesel_migrations/postgres",
    "diesel-async/postgres",
]
sqlite   = [
    "diesel/sqlite",
    "diesel/returning_clauses_for_sqlite_3_35",
    "diesel_migrations/sqlite",
    "diesel-async/sqlite",
]
```

Exactly one of these features must be active. The `mxd` crate emits a
compile-time error if both or neither are enabled.

and enable the feature you actually link at build-time. If you use the
`diesel` CLI for manual migration commands, install it with matching features:

```bash
cargo install diesel_cli --no-default-features --features sqlite,postgres
```

---

## 4 Running the migrations from code

```rust
use diesel::prelude::*;
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};

#[cfg(feature = "sqlite")]
pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations/sqlite");
#[cfg(feature = "postgres")]
pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations/postgres");

pub fn run_migrations<C>(conn: &mut C) -> anyhow::Result<()>
where
    C: diesel::connection::Connection + MigrationHarness<diesel::backend::Backend>,
{
    // Migrations are embedded at compile time for the selected backend.
    conn.run_pending_migrations(MIGRATIONS)?;
    Ok(())
}
```

---

## 5 Summary

- **Use backend-suffixed files (`up.postgres.sql` / `up.sqlite.sql`)** whenever
  DDL diverges – Diesel automatically chooses the correct one.
- Keep Rust-side types in `schema.rs` backend-agnostic (`Integer`, `Text`,
  `Bool`, `Timestamp`).
- For features that SQLite simply lacks (JSONB, expression indexes, row-level
  security) you must either introduce conditional code paths or limit those
  features to the Postgres deployment.
- When using SQLite, ensure your SQLite build was compiled with the `JSON1`
  extension and support for recursive CTEs.
- When using PostgreSQL, ensure the server version is **14 or greater**.
  The application performs a runtime check and fails on older versions.

With that structure you can `cargo build --features postgres` for the version
that targets *postgresql-embedded* (or a real server) and
`cargo build --features sqlite` for the lightweight single-file deployment,
without touching the migration history.
